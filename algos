//insertion sort

for j <-2 to n
a[j]=key
i=j-1
while(i>0&&a[j]>key)
{
	a[i+1]<-a[i]
	i--
	
	}
	a[i+1]=key
	
//merge sort

n=1 done
1/2 1/2 array divide and sort recurcively
by same method 
merge them

//binary search
a[i]==key done 
a[i]>key right subarray
a[i]<key left subarray
do it again and again till u find it

//quick sort

a[p]<-pivot
i<-p
for i<- p+1 to q
a[j]<pivot
i++;
swap a[j] with a[i]
a[p]<-a[i]
return i
//heap sort

size=n
build max heap
replace a[n] with a[1]
n--
max heapify(a,1)
do again and again
//counting sort

for i<- 0 to k(max element)
c[k]=0
for j<=0 to n
c[a[i]]++
for j<- 1 to k
c[a[j]]=c[a[j]]+c[a[j-1]]
for i<-n to 0
b[c[a[j]]]=a[j]
c[a[j]]-- 

//radix sort
start sorting from ones digit ie. take the ones digit of all numbers and pass them in a containerand apply counting sort on them
arrange accordingly and then do same with tens digit and so on.

//bucket sort
actually the numbers are in the range [0,1) make buckets accordingly means container[0] place zeros and container[1] .1's and container[2] 
.2's do this for all the numbers and sort all the buckets and then concatinate all the buckets to get the final output.









