//insertion sort

for j <-2 to n
a[j]=key
i=j-1
while(i>0&&a[j]>key)
{
	a[i+1]<-a[i]
	i--
	
	}
	a[i+1]=key
	
//merge sort

n=1 done
1/2 1/2 array divide and sort recurcively
by same method 
merge them

//binary search
a[i]==key done 
a[i]>key right subarray
a[i]<key left subarray
do it again and again till u find it

//quick sort
(partition algo)

a[p]<-pivot
i<-p
for i<- p+1 to q
a[j]<pivot
i++;
swap a[j] with a[i]
a[p]<-a[i]
return i
//heap sort

size=n
build max heap
replace a[n] with a[1]
n--
max heapify(a,1)
do again and again
//counting sort

for i<- 0 to k(max element)
c[k]=0
for j<=0 to n
c[a[i]]++
for j<- 1 to k
c[a[j]]=c[a[j]]+c[a[j-1]]
for i<-n to 0
b[c[a[j]]]=a[j]
c[a[j]]-- 

//radix sort
start sorting from ones digit ie. take the ones digit of all numbers and pass them in a containerand apply counting sort on them
arrange accordingly and then do same with tens digit and so on.

//bucket sort
actually the numbers are in the range [0,1) make buckets accordingly means container[0] place zeros and container[1] .1's and container[2] 
.2's do this for all the numbers and sort all the buckets and then concatinate all the buckets to get the final output.

//Order stastatics
given elements find the ith smallest element from a given container 0<=i<=n

i=1 1st smallest
i=n max element
i=n/2 median

for i=1 and i=n use linear search over the container taking a[0] as the max element
for order of nlogn sort the container and output the same
to find better than nlogn we can use partition subroutine from quick sort on container p->q
algorithm
if p==q return a[p]
else
partition algorithm on p->q 
r is the index where x(pivot element) has been put
k<-r-p+1 is the rank of x 
if(i==k)
return x
if(i<k)
do partition subroutine on left sub container (a[p....r-1],i)
else if(i>k)
do partition sunbroutine on right sub container (a[r+1....q],i-k)
to make this algorithm to make it lucky every time every time the run time depends on the partition of the container
so we choose the pivot randomly this way there is more possibility of choosing a good pivot for good partition
rand-select(a[p....q],i) so expected run time comes out to be order of n.









